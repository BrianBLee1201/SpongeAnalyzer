plugins {
	id 'fabric-loom' version '1.15.0-alpha.6'
	id 'maven-publish'
}

group = "com.brianlee"
version = "0.0.1"

repositories {
	// Loom adds the main repos automatically, but keeping this is fine.
	maven { url = "https://maven.fabricmc.net/" }
}

dependencies {
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_api_version}"
}

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = "UTF-8"
	// optional but nice for debugging
	options.release = 21
}

tasks.withType(JavaExec).configureEach {
    // Always tell the mod where the project root is so it can write results.csv next to the repo.
    systemProperty "spongemonument.projectDir", project.projectDir.absolutePath

    // Forward ALL SpongeAnalyzer runtime knobs without having to maintain a list.
    // This lets the README document only the common flags, while power users can still add more.
    System.getProperties().stringPropertyNames().each { key ->
        if (key == "spongemonument.projectDir" || key.startsWith("sponge.")) {
            def v = System.getProperty(key)
            if (v != null) {
                systemProperty key, v
            }
        }
    }
}

// Players should normally use runAll (or analyzeMonuments alias) instead of runServer directly.
tasks.named("runServer") {
    group = null
    description = "(internal) Used by runAll to execute analysis phases."

    doFirst {
        def allow = System.getProperty("sponge.allowRunServer", "0")
        if (allow != "1") {
            throw new GradleException("Do not run 'runServer' directly. Use: ./gradlew -Dsponge.seed=<seed> runAll  (If you really need runServer for debugging, add -Dsponge.allowRunServer=1)")
        }

        def seed = System.getProperty("sponge.seed")
        if (seed == null) return

        def propsFile = file("run/server.properties")
        propsFile.parentFile.mkdirs()

        def props = new Properties()
        if (propsFile.exists()) {
            propsFile.withInputStream { props.load(it) }
        }

        props.setProperty("level-seed", seed)
        props.setProperty("max-tick-time", "-1")
        props.setProperty("sync-chunk-writes", "false")

        propsFile.withOutputStream { out ->
            props.store(out, "Updated by SpongeMonument runServer")
        }

        println "[SpongeMonument] Wrote run/server.properties level-seed=" + seed
    }
}

tasks.register("deleteRunWorld", Delete) {
    delete file("run/world")
}

tasks.named("runServer") {
    finalizedBy("deleteRunWorld")
}

// DEBUGGING: Enable remote debugging on server run
// loom {
//   runs {
//     server {
//       vmArg "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005"
//     }
//   }
// }

// Capture stable paths at configuration time (avoids Task.project usage at execution time)
def SPONGE_REPO_DIR = project.projectDir.absolutePath

// One-command driver: coords -> batch analyses -> merge.
// This intentionally runs multiple *separate* Gradle/Minecraft processes to avoid trying to restart
// the Minecraft server in the same JVM.
tasks.register("runAll") {
    group = "application"
    description = "Run coords -> batch analyses -> merge (single command). Requires -Dsponge.seed=<seed>. Optional: -Dsponge.radiusBlocks, -Dsponge.maxResults, -Dsponge.batchSize."

    doLast {
        def seed = System.getProperty("sponge.seed")
        if (seed == null || seed.isBlank()) {
            throw new GradleException("Missing -Dsponge.seed=<seed> (required)")
        }

        def radiusBlocks = System.getProperty("sponge.radiusBlocks", "20000")
        def maxResults  = System.getProperty("sponge.maxResults", "100000")
        def batchSize   = Integer.parseInt(System.getProperty("sponge.batchSize", "1000"))

        // Internal paths/files (not user-facing; keep stable to avoid confusing players)
        def outDir     = SPONGE_REPO_DIR
        def candidates = "candidates.csv"

        def isWindows = System.getProperty("os.name").toLowerCase().contains("win")
        def gradlewCmd = isWindows ? ["cmd", "/c", "gradlew.bat"] : ["./gradlew"]

        def common = [
            "-Dsponge.seed=${seed}",
            "-Dsponge.radiusBlocks=${radiusBlocks}",
            "-Dsponge.maxResults=${maxResults}",
            "-Dsponge.batchSize=${batchSize}",
            "-Dsponge.outDir=${outDir}",
            "-Dsponge.candidatesFile=${candidates}"
        ]

        // Use ExecOperations to avoid deprecated Task.project and to work on newer Gradle versions.
        def execOps = services.get(org.gradle.process.ExecOperations)

        // 1) Coords phase
        execOps.exec {
            commandLine(*gradlewCmd, *common, "-Dsponge.allowRunServer=1", "-Dsponge.mode=coords", "runServer")
        }

        // Count candidates (CSV lines minus header)
        def candFile = new File(outDir, candidates)
        if (!candFile.exists()) {
            throw new GradleException("candidates file not found: ${candFile.absolutePath}")
        }
        def lines = candFile.readLines("UTF-8")
        def count = Math.max(0, lines.size() - 1)
        if (count == 0) {
            logger.lifecycle("[SpongeMonument] No candidates found; skipping analysis/merge.")
            return
        }

        def batches = (int) Math.ceil(count / (double) batchSize)
        logger.lifecycle("[SpongeMonument] Candidates=${count}, batchSize=${batchSize}, batches=${batches}")

        // 2) Analyze phase (one server process per batch)
        for (int b = 0; b < batches; b++) {
            int start = b * batchSize
            execOps.exec {
                commandLine(*gradlewCmd, *common,
                    "-Dsponge.allowRunServer=1",
                    "-Dsponge.mode=analyze",
                    "-Dsponge.batchStart=${start}",
                    "runServer"
                )
            }
        }

        // 3) Merge phase
        execOps.exec {
            commandLine(*gradlewCmd, *common, "-Dsponge.allowRunServer=1", "-Dsponge.mode=merge", "runServer")
        }

        // 4) Cleanup intermediate artifacts so future runs don't accidentally mix data.
        try {
            def cand = new File(outDir, candidates)
            if (cand.exists()) cand.delete()

            def dir = new File(outDir)
            if (dir.exists()) {
                dir.listFiles()?.each { f ->
                    if (f.name.startsWith("results_part_") && f.name.endsWith(".csv")) {
                        f.delete()
                    }
                }
            }
        } catch (Throwable t) {
            logger.lifecycle("[SpongeMonument] Cleanup skipped: " + t.getMessage())
        }
    }
}