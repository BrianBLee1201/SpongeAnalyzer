plugins {
	id 'fabric-loom' version '1.15.0-alpha.6'
	id 'maven-publish'
}

group = "com.brianlee"
version = "0.0.1"

repositories {
	// Loom adds the main repos automatically, but keeping this is fine.
	maven { url = "https://maven.fabricmc.net/" }
}

dependencies {
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_api_version}"
}

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(21)
	}
}

tasks.withType(JavaCompile).configureEach {
	options.encoding = "UTF-8"
	// optional but nice for debugging
	options.release = 21
}

tasks.withType(JavaExec).configureEach {
    // Always tell the mod where the project root is so it can write results.csv next to the repo.
    systemProperty "spongemonument.projectDir", project.projectDir.absolutePath

    // Forward ALL SpongeAnalyzer runtime knobs without having to maintain a list.
    // This lets the README document only the common flags, while power users can still add more.
    System.getProperties().stringPropertyNames().each { key ->
        if (key == "spongemonument.projectDir" || key.startsWith("sponge.")) {
            def v = System.getProperty(key)
            if (v != null) {
                systemProperty key, v
            }
        }
    }
}

// Players should normally use runAll (or analyzeMonuments alias) instead of runServer directly.
tasks.named("runServer") {
    group = null
    description = "(internal) Used by runAll to execute analysis phases."

    doFirst {
        def allow = System.getProperty("sponge.allowRunServer", "0")
        if (allow != "1") {
            throw new GradleException("Do not run 'runServer' directly. Use: ./gradlew -Dsponge.seed=<seed> runAll  (If you really need runServer for debugging, add -Dsponge.allowRunServer=1)")
        }

        def seed = System.getProperty("sponge.seed")
        if (seed == null) return

        def propsFile = file("run/server.properties")
        propsFile.parentFile.mkdirs()

        def props = new Properties()
        if (propsFile.exists()) {
            propsFile.withInputStream { props.load(it) }
        }

        props.setProperty("level-seed", seed)
        props.setProperty("max-tick-time", "-1")
        props.setProperty("sync-chunk-writes", "false")

        propsFile.withOutputStream { out ->
            props.store(out, "Updated by SpongeMonument runServer")
        }

        println "[SpongeMonument] Wrote run/server.properties level-seed=" + seed
    }
}

tasks.register("deleteRunWorld", Delete) {
    delete file("run/world")
}

tasks.named("runServer") {
    finalizedBy("deleteRunWorld")
}

// DEBUGGING: Enable remote debugging on server run
// loom {
//   runs {
//     server {
//       vmArg "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005"
//     }
//   }
// }

// Capture stable paths at configuration time (avoids Task.project usage at execution time)
def SPONGE_REPO_DIR = project.projectDir.absolutePath

// One-command driver: coords -> batch analyses -> merge.
// This intentionally runs multiple *separate* Gradle/Minecraft processes to avoid trying to restart
// the Minecraft server in the same JVM.
tasks.register("runAll") {
    group = "application"
    description = "Run coords -> batch analyses -> merge (single command). Requires -Dsponge.seed=<seed>. Optional: -Dsponge.radiusBlocks, -Dsponge.excludeRadiusBlocks, -Dsponge.maxResults, -Dsponge.batchSize."

    doLast {
        def seed = System.getProperty("sponge.seed")
        if (seed == null || seed.isBlank()) {
            throw new GradleException("Missing -Dsponge.seed=<seed> (required)")
        }

        def radiusBlocks = System.getProperty("sponge.radiusBlocks", "20000")
        def excludeRadiusBlocks = System.getProperty("sponge.excludeRadiusBlocks", "0") // Optional exclude radius (square), default 0
        def maxResults  = System.getProperty("sponge.maxResults", "100000")
        def batchSize   = Integer.parseInt(System.getProperty("sponge.batchSize", "1000"))

        // Validate exclude radius (must be 0..radiusBlocks)
        try {
            long r = Long.parseLong(radiusBlocks)
            long ex = Long.parseLong(excludeRadiusBlocks)
            if (ex < 0) {
                throw new GradleException("-Dsponge.excludeRadiusBlocks must be >= 0")
            }
            if (ex > r) {
                throw new GradleException("-Dsponge.excludeRadiusBlocks (${ex}) must be <= -Dsponge.radiusBlocks (${r})")
            }
        } catch (NumberFormatException ignored) {
            throw new GradleException("-Dsponge.radiusBlocks and -Dsponge.excludeRadiusBlocks must be valid integers")
        }

        // Internal paths/files (not user-facing; keep stable to avoid confusing players)
        def outDir     = SPONGE_REPO_DIR
        def candidates = "candidates.csv"

        def isWindows = System.getProperty("os.name").toLowerCase().contains("win")
        def gradlewCmd = isWindows ? ["cmd", "/c", "gradlew.bat"] : ["./gradlew"]

        def common = [
            "-Dsponge.seed=${seed}",
            "-Dsponge.radiusBlocks=${radiusBlocks}",
            "-Dsponge.excludeRadiusBlocks=${excludeRadiusBlocks}",
            "-Dsponge.maxResults=${maxResults}",
            "-Dsponge.batchSize=${batchSize}",
            "-Dsponge.outDir=${outDir}",
            "-Dsponge.candidatesFile=${candidates}"
        ]

        // Use ExecOperations to avoid deprecated Task.project and to work on newer Gradle versions.
        def execOps = services.get(org.gradle.process.ExecOperations)

        // 1) Coords phase
        execOps.exec {
            commandLine(*gradlewCmd, *common, "-Dsponge.allowRunServer=1", "-Dsponge.mode=coords", "runServer")
        }

        // Count candidates (CSV lines minus header)
        def candFile = new File(outDir, candidates)
        if (!candFile.exists()) {
            throw new GradleException("candidates file not found: ${candFile.absolutePath}")
        }
        def lines = candFile.readLines("UTF-8")
        def count = Math.max(0, lines.size() - 1)
        if (count == 0) {
            logger.lifecycle("[SpongeMonument] No candidates found; skipping analysis/merge.")
            return
        }

        def batches = (int) Math.ceil(count / (double) batchSize)
        logger.lifecycle("[SpongeMonument] Candidates=${count}, batchSize=${batchSize}, batches=${batches}")

        // 2) Analyze phase (one server process per batch)
        for (int b = 0; b < batches; b++) {
            int start = b * batchSize
            execOps.exec {
                commandLine(*gradlewCmd, *common,
                    "-Dsponge.allowRunServer=1",
                    "-Dsponge.mode=analyze",
                    "-Dsponge.batchStart=${start}",
                    "runServer"
                )
            }
        }

        // 3) Merge phase
        execOps.exec {
            commandLine(*gradlewCmd, *common, "-Dsponge.allowRunServer=1", "-Dsponge.mode=merge", "runServer")
        }

        // 4) Cleanup intermediate artifacts so future runs don't accidentally mix data.
        try {
            def cand = new File(outDir, candidates)
            if (cand.exists()) cand.delete()

            def dir = new File(outDir)
            if (dir.exists()) {
                dir.listFiles()?.each { f ->
                    if (f.name.startsWith("results_part_") && f.name.endsWith(".csv")) {
                        f.delete()
                    }
                }
            }
        } catch (Throwable t) {
            logger.lifecycle("[SpongeMonument] Cleanup skipped: " + t.getMessage())
        }

        // 5) Optional Xaero waypoint export (controlled by JVM -Dsponge.* args)
        def xaeroExport = System.getProperty("sponge.xaeroExport", "0")
        // Robust: anything other than explicit "0" enables export.
        if (xaeroExport != "0") {
            def xaeroMinRooms = 4
            try {
                xaeroMinRooms = Integer.parseInt(System.getProperty("sponge.xaeroMinRooms", "4"))
            } catch (Exception e) {
                logger.lifecycle("[SpongeMonument] (xaero) Invalid -Dsponge.xaeroMinRooms, using 4")
            }
            def xaeroDims = System.getProperty("sponge.xaeroDims", "overworld").toLowerCase()
            def allowedDims = ["overworld", "nether", "both"]
            if (!allowedDims.contains(xaeroDims)) {
                logger.lifecycle("[SpongeMonument] (xaero) Invalid -Dsponge.xaeroDims, using 'overworld'")
                xaeroDims = "overworld"
            }
            def xaeroColor = 11
            try {
                xaeroColor = Integer.parseInt(System.getProperty("sponge.xaeroColor", "11"))
                if (xaeroColor < 0 || xaeroColor > 15) {
                    logger.lifecycle("[SpongeMonument] (xaero) -Dsponge.xaeroColor must be between 0 and 15, using 11")
                    xaeroColor = 11
                }
            } catch (Exception e) {
                logger.lifecycle("[SpongeMonument] (xaero) Invalid -Dsponge.xaeroColor, using 11")
                xaeroColor = 11
            }
            def resultsFile = new File(outDir, "results.csv")
            if (!resultsFile.exists() || resultsFile.length() == 0) {
                logger.lifecycle("[SpongeMonument] (xaero) results.csv missing or empty; skipping Xaero export.")
            } else {
                def resultLines = resultsFile.readLines("UTF-8")
                if (resultLines.size() <= 1) {
                    logger.lifecycle("[SpongeMonument] (xaero) results.csv empty; skipping Xaero export.")
                } else {
                    // Parse header to find columns
                    def header = resultLines[0].split(",")
                    def xIdx = header.findIndexOf { it.trim() == "x" }
                    def zIdx = header.findIndexOf { it.trim() == "z" }
                    def roomIdx = header.findIndexOf { it.trim() == "inferred_sponge_rooms" }
                    if (xIdx == -1 || zIdx == -1 || roomIdx == -1) {
                        logger.lifecycle("[SpongeMonument] (xaero) results.csv missing required columns; skipping Xaero export.")
                    } else {
                        def overworldWpts = []
                        def netherWpts = []
                        for (int i = 1; i < resultLines.size(); ++i) {
                            def row = resultLines[i].split(",")
                            if (row.size() <= Math.max(xIdx, Math.max(zIdx, roomIdx))) continue
                            def x = 0
                            def z = 0
                            def rooms = 0
                            try {
                                x = Integer.parseInt(row[xIdx].trim())
                                z = Integer.parseInt(row[zIdx].trim())
                                rooms = Integer.parseInt(row[roomIdx].trim())
                            } catch (Exception e) {
                                continue
                            }
                            if (rooms < xaeroMinRooms) continue
                            // Overworld waypoint
                            if (xaeroDims == "overworld" || xaeroDims == "both") {
                                def owLine = "waypoint:${rooms}:${rooms}:${x}:63:${z}:${xaeroColor}:false:0:gui.xaero_default:false:0:0"
                                overworldWpts << owLine
                            }
                            // Nether waypoint (coords divided by 8, floored)
                            if (xaeroDims == "nether" || xaeroDims == "both") {
                                def nx = (int)Math.floor(x / 8.0)
                                def nz = (int)Math.floor(z / 8.0)
                                def netherLine = "waypoint:${rooms}:${rooms}:${nx}:128:${nz}:${xaeroColor}:false:0:gui.xaero_default:false:0:0"
                                netherWpts << netherLine
                            }
                        }
                        if ((xaeroDims == "overworld" || xaeroDims == "both") && overworldWpts.size() > 0) {
                            def owFile = new File(outDir, "overworld_waypoints.txt")
                            owFile.withWriter("UTF-8") { w ->
                                overworldWpts.each { w.writeLine(it) }
                            }
                            logger.lifecycle("[SpongeMonument] (xaero) Wrote ${overworldWpts.size()} overworld waypoints to ${owFile.name}")
                        }
                        if ((xaeroDims == "nether" || xaeroDims == "both") && netherWpts.size() > 0) {
                            def nFile = new File(outDir, "nether_waypoints.txt")
                            nFile.withWriter("UTF-8") { w ->
                                netherWpts.each { w.writeLine(it) }
                            }
                            logger.lifecycle("[SpongeMonument] (xaero) Wrote ${netherWpts.size()} nether waypoints to ${nFile.name}")
                        }
                        if ((xaeroDims == "overworld" || xaeroDims == "both") && overworldWpts.size() == 0) {
                            logger.lifecycle("[SpongeMonument] (xaero) No overworld waypoints to write (filtered by minRooms?)")
                        }
                        if ((xaeroDims == "nether" || xaeroDims == "both") && netherWpts.size() == 0) {
                            logger.lifecycle("[SpongeMonument] (xaero) No nether waypoints to write (filtered by minRooms?)")
                        }
                    }
                }
            }
        }
    }
}